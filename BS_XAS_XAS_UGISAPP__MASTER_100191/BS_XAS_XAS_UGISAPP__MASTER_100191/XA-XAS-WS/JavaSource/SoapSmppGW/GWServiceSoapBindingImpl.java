/**
 * Web Service implementation.
 * 
 * --- WARNING ---  WARNING --- WARNING --- WARNING --- WARNING --- WARNING --- WARNING --- WARNING --- WARNING ---
 * WHEN CREATING WEB SERVICE BOTTOM UP WITH
 * Web Services \ Create Web Service
 * --- WARNING --- WARNING --- WARNING --- WARNING --- WARNING --- WARNING --- WARNING --- WARNING --- WARNING ---
 * 
 * After the wizard completion re-setup the security authentication method for the SendSms & SendSms2 web services.
 * 
 * In WebContent \ WEB-INF \ webservices.xml \ Security Extensions 
 * \ Web Service Description Externsion [SendSmsService & SendSms2Service] \ Port Component Binding [SmsNotificationServicePort] 
 * \ Login Config \ Add [BasicAuth] (do not add the LTPA)
 * 
 * For Service it.eng.service.mgp.sms.SmsNotification add only BasicAuth.
 */	

/**
 * Implementation of the <i>SmsNotificationService</i> of Vodafone provider.
 * 
 * <p>Implements the Delivery Report and Mobile Originated service for the Vodafone provider WebService.</p>
 * <p>Use by extending it in the SmsNotificationServiceSoapBindingImpl class generated by the WebService generated
 * modify the class as the following row: </p>
 * <code>
 *   public class SmsNotificationServiceSoapBindingImpl <b>extends ServiceLifecycle</b> 
 * </code> 
 */

package SoapSmppGW;

import ie.omk.smpp.util.DefaultAlphabetEncoding;
import ie.omk.smpp.util.UCS2Encoding;
import it.usi.xframe.system.eservice.ServiceFactoryException;
import it.usi.xframe.xas.bfimpl.a2psms.dataobject.InternalSmsRequest;
import it.usi.xframe.xas.bfintf.IXasSendsmsServiceFacade;
import it.usi.xframe.xas.bfutil.ConstantsSms;
import it.usi.xframe.xas.bfutil.XasServiceFactory;
import it.usi.xframe.xas.bfutil.data.DeliveryResponse;
import it.usi.xframe.xas.util.json.XConstants;
import it.usi.xframe.xas.wsutil.DeliveryReport;
import it.usi.xframe.xas.wsutil.ENUM_STATUS;
import it.usi.xframe.xas.wsutil.MobileOriginated;

import java.io.PrintWriter;
import java.io.StringWriter;
import java.io.UnsupportedEncodingException;
import java.rmi.RemoteException;

import org.apache.log4j.MDC;
import org.apache.soap.encoding.Hex;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import eu.unicredit.xframe.slf.SmartLog;
import eu.unicredit.xframe.slf.UUID;

public class GWServiceSoapBindingImpl implements SoapSmppGW.GWService{
	private static final long serialVersionUID = 1L;
	private static Logger logger = LoggerFactory.getLogger(GWServiceSoapBindingImpl.class);

	public SoapSmppGW.Submit_resp submit(SoapSmppGW.Submit_sm sm, SoapSmppGW.GWSession gws) throws java.rmi.RemoteException {
		IXasSendsmsServiceFacade facade;
		String myUUID = UUID.randomUUID().toString();
	    try {
	
			SmartLog sl = new SmartLog().logItCompact(ConstantsSms.MY_APPL_ID, ConstantsSms.MY_LOG_VER, "GWServiceSoapBindingImpl", myUUID, SmartLog.V_SCOPE_DEBUG)
										.logIt(SmartLog.K_METHOD, "deliver", SmartLog.K_PHASE, SmartLog.V_PHASE_ENTER).preset("default"); 
	
				// Write to log the associated UUID and CRID if present
			String myCRID = (String) MDC.get(ConstantsSms.MY_CRID_KEY);
				if (myCRID != null) {
					logger.info(sl.logIt(SmartLog.K_STEP, "correlating", SmartLog.K_CRID, myCRID).getLogRow(true));
				}
	
				// If debug dump parameters
				if (logger.isDebugEnabled()) { 
				logger.debug(sl.reload("default").logIt(SmartLog.K_STEP, "", SmartLog.K_PARAMS, XConstants.XSTREAMER.toXML(sm)).getLogRow());
			}
	        facade = XasServiceFactory.getInstance().getXasSendsmsServiceFacade();
	    } catch (ServiceFactoryException e) {
	        throw new RemoteException("ServiceFactoryException", e);
	    }
	    
	    SoapSmppGW.Submit_resp resp = new SoapSmppGW.Submit_resp();
	    try {
		} finally {
			XasServiceFactory.getInstance().dispose(facade);
		}
	    	
		return resp;
	}

    public SoapSmppGW.Deliver_resp deliver(SoapSmppGW.Deliver_sm sm, SoapSmppGW.GWSession gws) throws java.rmi.RemoteException {
		IXasSendsmsServiceFacade facade;
		String myUUID = UUID.randomUUID().toString();
	    try {
	
			SmartLog sl = new SmartLog().logItCompact(ConstantsSms.MY_APPL_ID, ConstantsSms.MY_LOG_VER, "GWServiceSoapBindingImpl", myUUID, SmartLog.V_SCOPE_DEBUG)
										.logIt(SmartLog.K_METHOD, "deliver", SmartLog.K_PHASE, SmartLog.V_PHASE_ENTER).preset("default"); 
	
				// Write to log the associated UUID and CRID if present
			String myCRID = (String) MDC.get(ConstantsSms.MY_CRID_KEY);
				if (myCRID != null) {
					logger.info(sl.logIt(SmartLog.K_STEP, "correlating", SmartLog.K_CRID, myCRID).getLogRow(true));
				}
	
				// If debug dump parameters
				if (logger.isDebugEnabled()) { 
				logger.debug(sl.reload("default").logIt(SmartLog.K_STEP, "", SmartLog.K_PARAMS, XConstants.XSTREAMER.toXML(sm)).getLogRow());
			}
	        facade = XasServiceFactory.getInstance().getXasSendsmsServiceFacade();
	    } catch (ServiceFactoryException e) {
	        throw new RemoteException("ServiceFactoryException", e);
	    }
	    
	    SoapSmppGW.Deliver_resp resp = new SoapSmppGW.Deliver_resp();
	    try {
	    	String smsId = sm.getReceipted_message_id() != null ? sm.getReceipted_message_id().toString() : "";
	    	Byte data_coding = sm.getData_coding() != null ? sm.getData_coding() : new Byte((byte)0);
	    	int smscDeliveryReport = 0x04; // x x 0 0 0 1 x x Short Message contains SMSC Delivery Receipt
	    	int messageTypeMask = 0x3C; // x x Y Y Y Y x x -> Y Y Y Y message type
	    	int messageType = (sm.getEsm_class() != null ? sm.getEsm_class().intValue() : 0) & messageTypeMask;
	    	
	    	if (((messageType) ^ smscDeliveryReport) == 0) { // SMSC Delivery Report
	    		System.out.println("SMS DELIVERY REPORT");
		        DeliveryResponse deliveryResponse = null;
				DeliveryReport deliveryReport = new DeliveryReport();
				//deliveryReport.setProviderDate(mtDeliveryStatus.getDate()); 
				deliveryReport.setUuid(null); // Fetch UUID from table for the corresponding SmsId
				deliveryReport.setSmsIds(new String[] {smsId});	// mtDeliveryStatus.getSmsId()
				deliveryReport.setPhoneNumber(sm.getDestination_addr());				// mtDeliveryStatus.getDestAddr() 
				//deliveryReport.setDeliveryDate(mtDeliveryStatus.getDeliveryDate());
				if (sm.getMessage_state() != null) {
					switch (sm.getMessage_state().intValue()) {
						case 1: deliveryReport.setStatus(ENUM_STATUS.DELIVERED_TO_DEV);
								break;
						case 2: deliveryReport.setStatus(ENUM_STATUS.DROPPED_BY_SMSC);
								break;
						default: deliveryReport.setStatus(ENUM_STATUS.UNKNOWN_SMSC_RESPONSE);
								break;
					}
						
				} else {
					deliveryReport.setStatus(ENUM_STATUS.UNKNOWN_SMSC_RESPONSE);
				}
		
				deliveryResponse = facade.receiveVodafonePopDeliveryReport(deliveryReport);	// at the moment 'sender' is ignored
				resp.setCommand_status(0);
				resp.setError_code(deliveryResponse.getMessage());
				resp.setMessage_id(myUUID);
				if (! (ConstantsSms.XAS00000I_CODE.equals(deliveryResponse.getCode()) 
				    || ConstantsSms.XAS06080I_CODE.equals(deliveryResponse.getCode())
				    || ConstantsSms.XAS06082E_CODE.equals(deliveryResponse.getCode())
				    )) { 
					// XAS00000I, XAS00080I, XAS0082E - Do not retry. For other return code do a retry. 
					throw new RemoteException(deliveryResponse.getCode() + " " + deliveryResponse.getMessage() + " FORCED RETRY"); 
				}	    		
	    	} else { // MOBILE ORIGINATED
				MobileOriginated mobileOriginated = new MobileOriginated();
				//			mobileOriginated.setMoDate(moMessage.getDate()); 
							mobileOriginated.setSmsIds(new String[] {smsId}); 
				//	 		mobileOriginated.setProviderDate(moMessage.getSmscDate());
							mobileOriginated.setPhoneNumber(sm.getSource_addr());
							mobileOriginated.setMoDestinator(sm.getDestination_addr()); 
							mobileOriginated.setUuid(myUUID);
							
							if (new Byte((byte)InternalSmsRequest.ENCODING_GSM338).equals(data_coding)) {
					            mobileOriginated.setMsg((new DefaultAlphabetEncoding()).decodeString(sm.getShort_message().getBytes()));
							} else if (new Byte((byte)InternalSmsRequest.ENCODING_UCS2).equals(data_coding)) {
								try {
									
//									mobileOriginated.setMsg((new UCS2Encoding()).decodeString(sm.getShort_message().getBytes()));
									mobileOriginated.setMsg((new UCS2Encoding()).decodeString(Hex.decode((sm.getShort_message()))));
					            } catch (UnsupportedEncodingException e) {
					            	StringWriter errors = new StringWriter();
					            	e.printStackTrace(new PrintWriter(errors));
					 				throw new RuntimeException("UCS2 Decoding", e);
					             }	
							}
							
					
							DeliveryResponse deliveryResponse = facade.receiveVodafonePopMobileOriginated(mobileOriginated);	// at the moment 'sender' is ignored
							resp.setCommand_status(0);
							resp.setError_code(deliveryResponse.getMessage());
							resp.setMessage_id(myUUID);
							if (! (ConstantsSms.XAS00000I_CODE.equals(deliveryResponse.getCode()) 
							    || ConstantsSms.XAS06080I_CODE.equals(deliveryResponse.getCode())
							    || ConstantsSms.XAS06082E_CODE.equals(deliveryResponse.getCode())
							    )) { 
								// XAS00000I, XAS00080I, XAS0082E - Do not retry. For other return code do a retry. 
								throw new RemoteException(deliveryResponse.getCode() + " " + deliveryResponse.getMessage() + " FORCED RETRY"); 
							}
	    	}

	    } finally {
			XasServiceFactory.getInstance().dispose(facade);
		}
	    	
		return resp;
	}

}
